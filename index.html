// --- Debug-friendly AppKit provider helpers ---------------------

function waitForAppKitProvider(timeoutMs = 8000) {
  return new Promise((resolve) => {
    console.log("[debug] waitForAppKitProvider start, timeout:", timeoutMs);
    if (!window.appKit || typeof window.appKit.subscribeProviders !== "function") {
      console.log("[debug] waitForAppKitProvider - no window.appKit");
      return resolve(null);
    }

    let done = false;
    const unsubscribe = window.appKit.subscribeProviders((state) => {
      const prov = state && state["eip155"] ? state["eip155"] : null;
      console.log("[debug] subscribeProviders callback, prov:", !!prov, state);
      if (prov && !done) {
        done = true;
        try { if (typeof unsubscribe === "function") unsubscribe(); } catch(e) {}
        console.log("[debug] waitForAppKitProvider resolved with provider");
        resolve(prov);
      }
    });

    setTimeout(() => {
      if (!done) {
        done = true;
        try { if (typeof unsubscribe === "function") unsubscribe(); } catch(e) {}
        console.log("[debug] waitForAppKitProvider timed out, resolving null");
        resolve(null);
      }
    }, timeoutMs);
  });
}

async function checkProvidersOnVisibility() {
  try {
    console.log("[debug] checkProvidersOnVisibility start — appKitEip155Provider:", !!appKitEip155Provider, "providerInstance:", !!providerInstance);

    if (appKitEip155Provider) {
      console.log("[debug] appKitEip155Provider already set — nothing to do");
      return;
    }

    if (window.appKit && typeof window.appKit.subscribeProviders === "function") {
      const prov = await waitForAppKitProvider(4000);
      console.log("[debug] waitForAppKitProvider short returned:", !!prov);
      if (prov) {
        appKitEip155Provider = prov;
        await handleAppKitProvider(prov);
        return;
      }
    }

    // injected fallback
    if (window.ethereum) {
      try {
        console.log("[debug] trying window.ethereum.eth_accounts");
        const accounts = await window.ethereum.request({ method: "eth_accounts" });
        console.log("[debug] eth_accounts:", accounts && accounts.length);
        if (accounts && accounts.length) {
          providerInstance = window.ethereum;
          web3Instance = new Web3(providerInstance);
          attachProviderListeners(providerInstance);
          await restoreSessionFromAddress(accounts[0].toLowerCase());
          return;
        }
      } catch (e) {
        console.warn("[debug] eth_accounts error:", e);
      }
    }

    if (window.trustwallet && window.trustwallet.ethereum) {
      try {
        console.log("[debug] trying trustwallet.eth_accounts");
        const accounts = await window.trustwallet.ethereum.request({ method: "eth_accounts" });
        console.log("[debug] trustwallet accounts:", accounts && accounts.length);
        if (accounts && accounts.length) {
          providerInstance = window.trustwallet.ethereum;
          web3Instance = new Web3(providerInstance);
          attachProviderListeners(providerInstance);
          await restoreSessionFromAddress(accounts[0].toLowerCase());
          return;
        }
      } catch (e) {
        console.warn("[debug] trustwallet eth_accounts error:", e);
      }
    }

    console.log("[debug] checkProvidersOnVisibility finished without finding provider");
  } catch (e) {
    console.warn("[debug] checkProvidersOnVisibility error:", e);
  }
}

window.addEventListener("visibilitychange", function () {
  console.log("[debug] visibilitychange:", document.visibilityState);
  if (document.visibilityState === "visible") {
    setTimeout(checkProvidersOnVisibility, 300);
  }
});
window.addEventListener("focus", function () {
  console.log("[debug] window focus event");
  setTimeout(checkProvidersOnVisibility, 250);
});
